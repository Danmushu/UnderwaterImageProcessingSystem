# UIPS 项目答辩问题准备

本文档整理了项目答辩中可能被问到的问题及详细回答，按模块分类。

---

## 一、架构与技术选型

### Q1: 为什么选择前后端分离架构？

**回答：**

前后端分离架构的优势：

1. **职责分离**：后端专注于业务逻辑和数据处理，前端专注于用户界面和交互体验
2. **独立开发**：前后端可以并行开发，提高开发效率
3. **技术灵活**：前端可以是 WPF、Web、移动端等任意客户端，后端 API 保持不变
4. **易于维护**：修改前端不影响后端，反之亦然
5. **符合实验要求**：实验明确要求"后端 Web API 服务 + 前端客户端软件"

**项目实现：**
- 后端：ASP.NET Core Web API，监听 `https://localhost:7149`
- 前端：WPF 桌面客户端，通过 HTTP 请求与后端通信
- 通信方式：RESTful API + JSON 数据格式

---

### Q2: 为什么选择 WPF 而不是 WinForms？

**回答：**

| 特性 | WPF | WinForms |
|------|-----|----------|
| UI 设计 | XAML 声明式，支持数据绑定 | 代码式，手动更新 UI |
| 样式主题 | 支持全局样式、模板 | 样式能力有限 |
| MVVM 支持 | 原生支持 | 需要额外实现 |
| 现代 UI | Material Design 等库丰富 | 外观较传统 |
| 学习曲线 | 较陡 | 较平缓 |

**选择 WPF 的原因：**
1. 支持 MVVM 模式，代码结构更清晰
2. 数据绑定强大，UI 自动响应数据变化
3. Material Design In XAML 库提供现代化 UI
4. 更好的可维护性和可扩展性

---

### Q3: 项目用了哪些第三方库？各有什么作用？

**回答：**

**后端库：**
| 库名 | 作用 |
|------|------|
| `Microsoft.EntityFrameworkCore.Sqlite` | ORM 框架，操作 SQLite 数据库 |
| `BCrypt.Net-Next` | 密码哈希加密，安全存储密码 |
| `Microsoft.AspNetCore.Authentication.JwtBearer` | JWT 认证中间件 |

**前端库：**
| 库名 | 作用 |
|------|------|
| `MaterialDesignThemes` | Material Design 风格 UI 组件库 |
| `CommunityToolkit.Mvvm` | MVVM 框架，提供 ObservableObject、RelayCommand 等 |
| `Refit` | 类型安全的 HTTP 客户端，自动生成 API 调用代码 |
| `Microsoft.Extensions.Hosting` | 依赖注入容器 |

---

### Q4: 什么是 DTO？为什么要用 DTO？

**回答：**

**DTO（Data Transfer Object）** 是数据传输对象，用于在不同层之间传递数据。

**为什么不直接用实体类？**

```
实体类 (Entity)          DTO
├── Id                   ├── Id
├── UserName             ├── UserName
├── PasswordHash  ❌     ├── Role
├── Role                 └── (不暴露密码)
└── Images (导航属性)
```

**使用 DTO 的好处：**
1. **安全性**：不暴露敏感字段（如 PasswordHash）
2. **解耦**：API 返回格式与数据库结构独立
3. **灵活性**：可以组合多个实体的数据
4. **性能**：只传输需要的字段，减少数据量

**项目中的 DTO 示例：**
- `LoginRequestDto`：登录请求（UserName, Password）
- `LoginResponseDto`：登录响应（AccessToken, UserId, Role...）
- `ImageDto`：图片信息（Id, FileName, PreviewUrl...）

---

## 二、用户认证与安全

### Q5: JWT 是什么？如何工作的？

**回答：**

**JWT（JSON Web Token）** 是一种无状态的认证方案。

**结构：** `Header.Payload.Signature`

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.  // Header: 算法和类型
eyJzdWIiOiIxIiwibmFtZSI6ImFkbWluIn0.    // Payload: 用户信息
SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c  // Signature: 签名
```

**工作流程：**
```
1. 用户登录 → 服务端验证密码 → 生成 JWT Token → 返回给客户端
2. 客户端保存 Token（本地文件）
3. 后续请求携带 Token → Authorization: Bearer <token>
4. 服务端验证签名 → 解析用户信息 → 处理请求
```

**项目实现：**
```csharp
// 生成 Token 时嵌入的信息
var claims = new[]
{
    new Claim(JwtRegisteredClaimNames.Sub, user.Id.ToString()),  // 用户ID
    new Claim(ClaimTypes.Role, user.Role)  // 角色
};
```

**优点：**
- 无状态：服务端不存储会话
- 可扩展：天然支持分布式
- 自包含：Token 自带用户信息

---

### Q6: 密码是如何安全存储的？

**回答：**

使用 **BCrypt** 算法进行哈希加密。

**为什么不用 MD5/SHA？**
- MD5/SHA 速度太快，容易被暴力破解
- BCrypt 故意设计得很慢，增加破解成本
- BCrypt 自动加盐，相同密码产生不同哈希值

**代码实现：**
```csharp
// 注册时：加密密码
user.PasswordHash = BCrypt.Net.BCrypt.HashPassword(request.Password);
// 存储结果示例：$2a$11$N9qo8uLOickgx2ZMRZoMy...

// 登录时：验证密码
bool isValid = BCrypt.Net.BCrypt.Verify(inputPassword, user.PasswordHash);
```

**BCrypt 哈希值结构：**
```
$2a$11$N9qo8uLOickgx2ZMRZoMyeIjZRGe6...
 │  │  └─────────────────────────────── 哈希值
 │  └─────────────────────────────────── 盐值
 └────────────────────────────────────── 算法版本和成本因子
```

---

### Q7: 如何实现权限控制？

**回答：**

**两层权限控制：**

1. **认证（Authentication）**：验证用户身份
   - 使用 `[Authorize]` 特性
   - 未登录用户返回 401 Unauthorized

2. **授权（Authorization）**：验证用户权限
   - 使用 `[Authorize(Roles = "Admin")]` 特性
   - 非管理员返回 403 Forbidden

**代码示例：**
```csharp
// 需要登录才能访问
[Authorize]
public class ImageController : ControllerBase { }

// 需要管理员角色才能访问
[Authorize(Roles = "Admin")]
public class AdminController : ControllerBase { }
```

**前端权限控制：**
```csharp
// 根据角色显示/隐藏管理员按钮
if (_userSession.IsAdmin)
{
    AdminTab.Visibility = Visibility.Visible;
}
```

---

### Q8: JWT 和 Session 有什么区别？

**回答：**

| 特性 | Session | JWT |
|------|---------|-----|
| 状态存储 | 服务端（内存/Redis） | 客户端（Token 自带信息） |
| 服务端压力 | 需要存储所有会话 | 不存储，只验证签名 |
| 扩展性 | 多服务器需共享 Session | 天然支持分布式 |
| 注销 | 服务端删除即可 | 需要黑名单或等过期 |
| 适用场景 | 传统 Web 应用 | API、移动端、微服务 |

**本项目选择 JWT 的原因：**
1. WPF 客户端不是浏览器，Cookie 管理不方便
2. 无状态，服务端简单
3. 适合 RESTful API 风格

---

## 三、数据库与 ORM

### Q9: 什么是 ORM？为什么用 Entity Framework Core？

**回答：**

**ORM（Object-Relational Mapping）** 是对象关系映射，将数据库表映射为代码中的类。

**对比：**
```csharp
// 不用 ORM（裸 SQL）
var sql = "SELECT * FROM Users WHERE Id = @id";
var cmd = new SqlCommand(sql, connection);
cmd.Parameters.AddWithValue("@id", 1);
var reader = cmd.ExecuteReader();

// 使用 EF Core（ORM）
var user = await context.Users.FindAsync(1);
```

**EF Core 优势：**
1. **类型安全**：编译时检查，避免 SQL 拼写错误
2. **防 SQL 注入**：自动参数化查询
3. **代码简洁**：LINQ 查询，可读性强
4. **数据库无关**：切换数据库只需改配置
5. **迁移支持**：自动生成数据库结构变更脚本

---

### Q10: 项目的数据模型是怎样设计的？

**回答：**

**三个核心实体：**

```
User (用户)
├── Id (主键)
├── UserName (用户名，唯一)
├── PasswordHash (密码哈希)
├── Role (角色：User/Admin)
├── Images (导航属性：用户上传的图片)
└── Favourites (导航属性：用户的收藏)

Image (图片)
├── Id (主键)
├── OriginalFileName (原始文件名)
├── StoredFileName (存储文件名，GUID)
├── ContentType (MIME 类型)
├── FileSize (文件大小)
├── UploadedAt (上传时间)
├── OwnerId (外键：上传者)
└── Owner (导航属性：上传者)

Favourite (收藏)
├── Id (主键)
├── UserId (外键：用户)
├── ImageId (外键：图片)
├── CreatedAt (收藏时间)
├── User (导航属性)
└── Image (导航属性)
```

**关系：**
- User 1:N Image（一个用户可以上传多张图片）
- User N:M Image（通过 Favourite 表实现多对多收藏关系）

---

### Q11: 什么是数据库迁移？如何使用？

**回答：**

**迁移（Migration）** 是将代码中的模型变更同步到数据库的机制。

**工作流程：**
```bash
# 1. 修改实体类（如添加新字段）

# 2. 创建迁移
dotnet ef migrations add AddNewField

# 3. 应用迁移到数据库
dotnet ef database update
```

**项目中的自动迁移：**
```csharp
// Program.cs 启动时自动应用迁移
await dbContext.Database.MigrateAsync();
```

**迁移文件位置：** `src/UIPS.API/Migrations/`

---

## 四、前端架构

### Q12: 什么是 MVVM 模式？项目如何实现？

**回答：**

**MVVM（Model-View-ViewModel）** 是一种 UI 架构模式。

```
┌─────────────────────────────────────────────────┐
│  View (XAML)                                    │
│  - 只负责 UI 展示                                │
│  - 通过数据绑定连接 ViewModel                    │
└─────────────────────────────────────────────────┘
         ↑↓ 数据绑定 (Binding)
┌─────────────────────────────────────────────────┐
│  ViewModel (C#)                                 │
│  - 处理 UI 逻辑                                  │
│  - 暴露属性和命令                                │
│  - 不直接操作 UI 控件                            │
└─────────────────────────────────────────────────┘
         ↑↓ 调用
┌─────────────────────────────────────────────────┐
│  Model (C#)                                     │
│  - 数据模型                                      │
│  - 业务逻辑                                      │
│  - API 调用                                      │
└─────────────────────────────────────────────────┘
```

**项目实现：**
```xml
<!-- View: DashboardView.xaml -->
<Button Command="{Binding UploadFileCommand}" />
<ListBox ItemsSource="{Binding Images}" />
```

```csharp
// ViewModel: DashboardViewModel.cs
[ObservableProperty]
private ObservableCollection<dynamic> _images = new();

[RelayCommand]
private async Task UploadFileAsync() { ... }
```

**优势：**
1. View 和逻辑分离，易于测试
2. 数据绑定自动更新 UI
3. 代码复用性高

---

### Q13: 什么是依赖注入？项目如何使用？

**回答：**

**依赖注入（DI）** 是一种设计模式，将对象的创建和依赖关系交给容器管理。

**不用 DI：**
```csharp
public class LoginViewModel
{
    private readonly IAuthApi _authApi = new AuthApi(); // 硬编码依赖
}
```

**使用 DI：**
```csharp
public class LoginViewModel
{
    private readonly IAuthApi _authApi;
    
    public LoginViewModel(IAuthApi authApi) // 构造函数注入
    {
        _authApi = authApi;
    }
}
```

**项目中的 DI 配置（App.xaml.cs）：**
```csharp
services.AddSingleton<UserSession>();           // 单例：全局共享
services.AddTransient<LoginViewModel>();        // 瞬态：每次创建新实例
services.AddRefitClient<IAuthApi>();            // Refit 客户端
```

**生命周期：**
- `Singleton`：整个应用只有一个实例（如 UserSession）
- `Transient`：每次请求创建新实例（如 ViewModel）
- `Scoped`：每个作用域一个实例（Web 请求常用）

---

### Q14: Refit 是什么？如何工作的？

**回答：**

**Refit** 是一个类型安全的 HTTP 客户端库，通过接口定义自动生成 API 调用代码。

**定义接口：**
```csharp
public interface IAuthApi
{
    [Post("/api/auth/login")]
    Task<dynamic> LoginAsync([Body] object request);
    
    [Get("/api/images")]
    Task<dynamic> GetImages([Query] int pageIndex, [Query] int pageSize);
}
```

**使用：**
```csharp
// Refit 自动生成实现类
var response = await _authApi.LoginAsync(new { UserName = "admin", Password = "123" });
```

**优势：**
1. 类型安全，编译时检查
2. 代码简洁，无需手写 HttpClient
3. 自动序列化/反序列化 JSON
4. 支持拦截器（如自动添加 Token）

---

## 五、具体功能实现

### Q15: 图片上传是如何实现的？

**回答：**

**前端：**
```csharp
// 1. 打开文件选择对话框
var dialog = new OpenFileDialog { Filter = "图片文件|*.jpg;*.png" };

// 2. 读取文件流
using var stream = File.OpenRead(filePath);
var filePart = new StreamPart(stream, fileName, "image/jpeg");

// 3. 调用 API 上传
await imageApi.UploadImage(filePart);
```

**后端：**
```csharp
[HttpPost("upload")]
public async Task<IActionResult> Upload(IFormFile file)
{
    // 1. 生成唯一文件名
    var storedFileName = $"{Guid.NewGuid()}{extension}";
    
    // 2. 保存到本地文件系统
    await _fileService.SaveFileAsync(file.OpenReadStream(), storedFileName);
    
    // 3. 保存记录到数据库
    var image = new Image { OriginalFileName = file.FileName, ... };
    context.Images.Add(image);
    await context.SaveChangesAsync();
}
```

**文件存储位置：** `src/UIPS.API/Uploads/`

---

### Q16: 分页功能是如何实现的？

**回答：**

**后端：**
```csharp
// 接收分页参数
public async Task<ActionResult> GetImages([FromQuery] PaginatedRequestDto request)
{
    var query = context.Images.AsQueryable();
    
    // 计算总数
    var totalCount = await query.CountAsync();
    
    // 分页查询
    var items = await query
        .Skip((request.PageIndex - 1) * request.PageSize)
        .Take(request.PageSize)
        .ToListAsync();
    
    // 返回分页结果
    return Ok(new PaginatedResult<ImageDto>
    {
        Items = items,
        TotalCount = totalCount,
        PageIndex = request.PageIndex,
        PageSize = request.PageSize
    });
}
```

**前端：**
```csharp
// ViewModel 属性
[ObservableProperty] private int _currentPage = 1;
[ObservableProperty] private int _totalPages;

// 翻页命令
[RelayCommand]
private async Task GoToNextPageAsync()
{
    if (CurrentPage < TotalPages)
    {
        CurrentPage++;
        await LoadImagesAsync();
    }
}
```

---

### Q17: 收藏功能是如何实现的？

**回答：**

**数据模型：**
```csharp
public class Favourite
{
    public int Id { get; set; }
    public int UserId { get; set; }    // 谁收藏的
    public int ImageId { get; set; }   // 收藏的哪张图
    public DateTime CreatedAt { get; set; }
}
```

**后端 API：**
```csharp
[HttpPost("{id}/toggle-selection")]
public async Task<IActionResult> ToggleSelection(int id)
{
    var userId = GetCurrentUserId();
    var existing = await context.Favourites
        .FirstOrDefaultAsync(f => f.UserId == userId && f.ImageId == id);
    
    if (existing != null)
    {
        context.Favourites.Remove(existing);  // 取消收藏
    }
    else
    {
        context.Favourites.Add(new Favourite { UserId = userId, ImageId = id });  // 添加收藏
    }
    
    await context.SaveChangesAsync();
}
```

**前端 UI：**
```xml
<ToggleButton IsChecked="{Binding IsSelected}"
              Command="{Binding ToggleSelectionCommand}">
    <materialDesign:PackIcon Kind="Heart" />
</ToggleButton>
```

---

### Q18: 登录状态是如何保持的？

**回答：**

**流程：**
```
登录成功 → Token 保存到 UserSession → 持久化到本地文件
                                          ↓
程序重启 → 从本地文件恢复 Token → 自动跳过登录界面
```

**UserSession 实现：**
```csharp
public class UserSession
{
    private static readonly string TokenFilePath = 
        Path.Combine(Environment.GetFolderPath(
            Environment.SpecialFolder.LocalApplicationData), "UIPS", "session.json");
    
    // 登录时保存
    public void SetSession(string token, ...)
    {
        AccessToken = token;
        SaveSession();  // 写入本地文件
    }
    
    // 启动时恢复
    public UserSession()
    {
        LoadSession();  // 从本地文件读取
    }
}
```

**Token 存储位置：** `%LocalAppData%\UIPS\session.json`

---

## 六、项目亮点与扩展

### Q19: 项目有哪些亮点？

**回答：**

1. **完整的前后端分离架构**
   - RESTful API 设计规范
   - 清晰的接口文档

2. **安全性**
   - JWT 无状态认证
   - BCrypt 密码加密
   - 角色权限控制

3. **现代化技术栈**
   - .NET 8.0 最新版本
   - Material Design UI
   - MVVM 架构模式

4. **良好的代码结构**
   - 依赖注入
   - DTO 数据传输
   - 分层架构

5. **完善的功能**
   - 用户注册/登录
   - 图片上传/浏览/收藏
   - 管理员用户管理
   - 分页查询

---

### Q20: 项目还有哪些可以改进的地方？

**回答：**

1. **Refresh Token 机制**
   - 当前 Access Token 过期需要重新登录
   - 可以实现 Refresh Token 自动续期

2. **图片处理**
   - 添加缩略图生成
   - 图片压缩优化

3. **搜索功能**
   - 按文件名搜索
   - 按上传时间筛选

4. **批量操作**
   - 批量上传进度显示
   - 批量删除确认

5. **单元测试**
   - 增加 API 接口测试
   - 增加 ViewModel 测试

6. **部署优化**
   - Docker 容器化
   - 云存储（如 Azure Blob）

---

## 七、常见追问

### Q21: 如果用户量很大，系统会有什么瓶颈？

**回答：**

1. **数据库**：SQLite 是单文件数据库，并发能力有限
   - 解决：迁移到 PostgreSQL/MySQL

2. **文件存储**：本地存储容量有限
   - 解决：使用云存储（OSS/S3）

3. **API 性能**：单实例处理能力有限
   - 解决：负载均衡 + 多实例部署

4. **Token 验证**：每次请求都要验证签名
   - 解决：使用 Redis 缓存用户信息

---

### Q22: 如何防止 SQL 注入？

**回答：**

使用 Entity Framework Core 的 LINQ 查询，自动参数化：

```csharp
// 安全：EF Core 自动参数化
var user = await context.Users
    .FirstOrDefaultAsync(u => u.UserName == request.UserName);

// 危险：字符串拼接（本项目没有这样做）
var sql = $"SELECT * FROM Users WHERE UserName = '{request.UserName}'";
```

---

### Q23: 如何防止 XSS 攻击？

**回答：**

1. **后端**：API 返回 JSON 数据，不返回 HTML
2. **前端**：WPF 不是浏览器，不执行 JavaScript
3. **数据验证**：对用户输入进行验证和清理

---

### Q24: Token 泄露了怎么办？

**回答：**

1. **短期 Token**：设置较短的过期时间（当前 120 分钟）
2. **HTTPS**：传输加密，防止中间人攻击
3. **改进方案**：
   - 实现 Token 黑名单
   - 绑定客户端指纹
   - 实现强制下线功能

---

## 八、代码理解题

### Q25: 解释这段代码的作用

```csharp
services.AddRefitClient<IImageApi>()
    .ConfigureHttpClient(c => c.BaseAddress = new Uri(apiUrl))
    .AddHttpMessageHandler<AuthHeaderHandler>()
    .ConfigurePrimaryHttpMessageHandler(() => new HttpClientHandler
    {
        ServerCertificateCustomValidationCallback = (m, c, ch, e) => true
    });
```

**回答：**

这段代码配置 Refit HTTP 客户端：

1. `AddRefitClient<IImageApi>()` - 注册 IImageApi 接口的 Refit 实现
2. `ConfigureHttpClient(...)` - 设置 API 基础地址
3. `AddHttpMessageHandler<AuthHeaderHandler>()` - 添加拦截器，自动在请求头加 Token
4. `ConfigurePrimaryHttpMessageHandler(...)` - 忽略 SSL 证书验证（开发环境用）

---

### Q26: 解释 [ObservableProperty] 的作用

```csharp
[ObservableProperty]
private string _userName = string.Empty;
```

**回答：**

这是 CommunityToolkit.Mvvm 的源代码生成器特性，会自动生成：

```csharp
public string UserName
{
    get => _userName;
    set
    {
        if (_userName != value)
        {
            _userName = value;
            OnPropertyChanged(nameof(UserName));  // 通知 UI 更新
        }
    }
}
```

作用：当属性值变化时，自动通知绑定的 UI 控件更新显示。

---

### Q27: 解释 async/await 的作用

```csharp
public async Task<IActionResult> Login(LoginRequestDto request)
{
    var user = await context.Users.FirstOrDefaultAsync(...);
    ...
}
```

**回答：**

- `async` 标记方法为异步方法
- `await` 等待异步操作完成，但不阻塞线程
- 好处：数据库查询时，线程可以处理其他请求，提高并发能力
- 如果用同步方法，线程会被阻塞，浪费资源

---

*文档完*
